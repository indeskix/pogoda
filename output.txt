SRC/COMPONENTS/CITYCARD.JSX:

```
function CityCard({ city, onSelect, isSelected, isFavorite, onToggleFavorite }) {
  return (
    <li className={`city-card ${isSelected ? 'city-card--selected' : ''}`}>
      <button
        className="city-card-button"
        onClick={() => onSelect(city.id)}
      >
        <div className="city-card-header">
          <h3 className="city-card-name">{city.name}</h3>
          {onToggleFavorite && (
            <button
              type="button"
              className={`fav-button ${isFavorite ? 'fav-button--active' : ''}`}
              onClick={(e) => {
                e.stopPropagation();
                onToggleFavorite();
              }}
              aria-label={isFavorite ? 'Usu≈Ñ z ulubionych' : 'Dodaj do ulubionych'}
            >
              {isFavorite ? '‚òÖ' : '‚òÜ'}
            </button>
          )}
        </div>
      </button>
    </li>
  );
}

export default CityCard;

```

SRC/COMPONENTS/CITYDETAILS.JSX:

```
import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import axios from 'axios';
import { convertTemperature } from '../utils/temperature';

function getWindDirection(windDegrees) {
  if (windDegrees === null || windDegrees === undefined) return null;
  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const roundedIndex = Math.round(windDegrees / 45) % 8;
  return directions[roundedIndex];
}

function getDayLabel(dateString) {
  const date = new Date(dateString);
  const dayIndex = date.getDay();
  const dayLabels = ['Nd', 'Pon', 'Wt', '≈ör', 'Czw', 'Pt', 'Sob'];
  return dayLabels[dayIndex];
}

function getWeatherDescription(mainCondition) {
  if (!mainCondition) {
    return 'Brak danych';
  }

  switch (mainCondition) {
    case 'Clear':
      return 'S≈Çonecznie';
    case 'Clouds':
      return 'Pochmurno';
    case 'Rain':
      return 'Deszcz';
    case 'Snow':
      return '≈önieg';
    case 'Thunderstorm':
      return 'Burza';
    case 'Drizzle':
      return 'M≈ºawka';
    case 'Mist':
    case 'Fog':
    case 'Haze':
    case 'Smoke':
    case 'Dust':
    case 'Sand':
    case 'Ash':
    case 'Squall':
    case 'Tornado':
      return 'Mglisto';
    default:
      return mainCondition;
  }
}

function getWeatherEmoji(mainCondition) {
  switch (mainCondition) {
    case 'Clear':
      return '‚òÄÔ∏è';
    case 'Clouds':
      return '‚òÅÔ∏è';
    case 'Rain':
      return 'üåßÔ∏è';
    case 'Snow':
      return '‚ùÑÔ∏è';
    case 'Thunderstorm':
      return '‚õàÔ∏è';
    case 'Drizzle':
      return 'üå¶Ô∏è';
    case 'Mist':
    case 'Fog':
    case 'Haze':
      return 'üå´Ô∏è';
    default:
      return 'üå°Ô∏è';
  }
}

function CityDetails({ city }) {
  const unit = useSelector((state) => state.temperature.unit);
  const [currentWeather, setCurrentWeather] = useState(null);
  const [forecastDays, setForecastDays] = useState([]);
  const [todayPrecipitation, setTodayPrecipitation] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState(null);

  useEffect(() => {
    const apiKey = import.meta.env.VITE_API_KEY;
    if (!apiKey) {
      setErrorMessage('Brak klucza API.');
      setCurrentWeather(null);
      setForecastDays([]);
      setTodayPrecipitation(null);
      return;
    }

    let wasCancelled = false;

    const fetchWeatherData = async () => {
      setIsLoading(true);
      setErrorMessage(null);
      setCurrentWeather(null);
      setForecastDays([]);
      setTodayPrecipitation(null);

      try {
        const [weatherResponse, forecastResponse] = await Promise.all([
          axios.get('https://api.openweathermap.org/data/2.5/weather', {
            params: {
              lat: city.lat,
              lon: city.lon,
              units: 'metric',
              appid: apiKey,
            },
          }),
          axios.get('https://api.openweathermap.org/data/2.5/forecast', {
            params: {
              lat: city.lat,
              lon: city.lon,
              units: 'metric',
              appid: apiKey,
            },
          }),
        ]);

        if (wasCancelled) return;

        const weatherData = weatherResponse.data;
        const forecastData = forecastResponse.data;

        const currentWeatherData = {
          temperatureCelsius: weatherData.main?.temp ?? null,
          mainCondition: weatherData.weather?.[0]?.main ?? null,
          iconCode: weatherData.weather?.[0]?.icon ?? null,
          windSpeedKilometersPerHour:
            weatherData.wind?.speed !== undefined && weatherData.wind?.speed !== null
              ? weatherData.wind.speed * 3.6
              : null,
          windDegrees: weatherData.wind?.deg ?? null,
          cloudinessPercent: weatherData.clouds?.all ?? null,
          humidityPercent: weatherData.main?.humidity ?? null,
          pressureHpa: weatherData.main?.pressure ?? null,
        };

        const forecastGroupsByDate = {};

        forecastData.list.forEach((forecastItem) => {
          const forecastDate = new Date(forecastItem.dt * 1000);
          const dateKey = forecastDate.toISOString().slice(0, 10);

          const minTemperatureCelsius = forecastItem.main?.temp_min ?? null;
          const maxTemperatureCelsius = forecastItem.main?.temp_max ?? null;
          const rainAmountInThreeHours = forecastItem.rain?.['3h'] ?? null;
          const snowAmountInThreeHours = forecastItem.snow?.['3h'] ?? null;
          const precipitationProbability = forecastItem.pop ?? null;
          const precipitationAmount = (rainAmountInThreeHours ?? 0) + (snowAmountInThreeHours ?? 0);
          const mainCondition = forecastItem.weather?.[0]?.main ?? 'Clear';
          const iconCode = forecastItem.weather?.[0]?.icon ?? null;

          if (!forecastGroupsByDate[dateKey]) {
            forecastGroupsByDate[dateKey] = {
              dateKey,
              minTemperatureCelsius,
              maxTemperatureCelsius,
              maxPrecipitationProbability: precipitationProbability,
              totalPrecipitationMillimeters: precipitationAmount,
              hasRain: rainAmountInThreeHours > 0,
              hasSnow: snowAmountInThreeHours > 0,
              conditionCounts: {},
              iconCode,
            };
          } else {
            const dateGroup = forecastGroupsByDate[dateKey];

            if (minTemperatureCelsius !== null) {
              const isMinNotSet = dateGroup.minTemperatureCelsius === null;
              dateGroup.minTemperatureCelsius = isMinNotSet
                ? minTemperatureCelsius
                : Math.min(dateGroup.minTemperatureCelsius, minTemperatureCelsius);
            }

            if (maxTemperatureCelsius !== null) {
              const isMaxNotSet = dateGroup.maxTemperatureCelsius === null;
              dateGroup.maxTemperatureCelsius = isMaxNotSet
                ? maxTemperatureCelsius
                : Math.max(dateGroup.maxTemperatureCelsius, maxTemperatureCelsius);
            }

            if (precipitationProbability !== null) {
              dateGroup.maxPrecipitationProbability = Math.max(
                dateGroup.maxPrecipitationProbability,
                precipitationProbability,
              );
            }

            dateGroup.totalPrecipitationMillimeters += precipitationAmount;
            dateGroup.hasRain = dateGroup.hasRain || rainAmountInThreeHours > 0;
            dateGroup.hasSnow = dateGroup.hasSnow || snowAmountInThreeHours > 0;
          }

          const dateGroupForConditions = forecastGroupsByDate[dateKey];
          dateGroupForConditions.conditionCounts[mainCondition] =
            (dateGroupForConditions.conditionCounts[mainCondition] || 0) + 1;

          if (!dateGroupForConditions.iconCode && iconCode) {
            dateGroupForConditions.iconCode = iconCode;
          }
        });

        const sortedDateKeys = Object.keys(forecastGroupsByDate).sort();

        const days = sortedDateKeys.slice(0, 5).map((dateKey) => {
          const dateGroup = forecastGroupsByDate[dateKey];

          const sortedConditions = Object.entries(dateGroup.conditionCounts).sort(
            (firstEntry, secondEntry) => secondEntry[1] - firstEntry[1],
          );

          const mostFrequentCondition = sortedConditions[0]?.[0] || 'Clear';

          let precipitationTypeLabel = 'brak opad√≥w';
          if (dateGroup.hasRain && dateGroup.hasSnow) {
            precipitationTypeLabel = 'deszcz i ≈õnieg';
          } else if (dateGroup.hasSnow) {
            precipitationTypeLabel = '≈õnieg';
          } else if (dateGroup.hasRain) {
            precipitationTypeLabel = 'deszcz';
          }

          return {
            dateKey: dateGroup.dateKey,
            dayLabel: getDayLabel(dateGroup.dateKey),
            minTemperatureCelsius: dateGroup.minTemperatureCelsius,
            maxTemperatureCelsius: dateGroup.maxTemperatureCelsius,
            precipitationProbabilityPercent: Math.round(
              dateGroup.maxPrecipitationProbability * 100,
            ),
            precipitationAmountMillimeters:
              Math.round(dateGroup.totalPrecipitationMillimeters * 10) / 10,
            precipitationTypeLabel,
            mainCondition: mostFrequentCondition,
            mainConditionLabel: getWeatherDescription(mostFrequentCondition),
            mainConditionEmoji: getWeatherEmoji(mostFrequentCondition),
            iconCode: dateGroup.iconCode,
          };
        });

        const todayGroup = days[0] || null;

        setCurrentWeather(currentWeatherData);
        setForecastDays(days);
        setTodayPrecipitation(todayGroup);
      } catch (error) {
        if (!wasCancelled) {
          console.error('B≈ÇƒÖd pobierania danych pogodowych:', error);
          setErrorMessage('Nie uda≈Ço siƒô pobraƒá danych pogodowych.');
        }
      } finally {
        if (!wasCancelled) {
          setIsLoading(false);
        }
      }
    };

    fetchWeatherData();

    return () => {
      wasCancelled = true;
    };
  }, [city]);

  if (isLoading) {
    return (
      <div className="city-details">
        <p>≈Åadowanie danych...</p>
      </div>
    );
  }

  if (errorMessage) {
    return (
      <div className="city-details">
        <p>{errorMessage}</p>
      </div>
    );
  }

  if (!currentWeather) {
    return (
      <div className="city-details">
        <p>Brak danych pogodowych.</p>
      </div>
    );
  }

  const currentTemperature =
    currentWeather.temperatureCelsius !== null
      ? convertTemperature(currentWeather.temperatureCelsius, unit)
      : null;
  const windDirection = getWindDirection(currentWeather.windDegrees);
  const currentConditionLabel = getWeatherDescription(currentWeather.mainCondition);

  return (
    <div className="city-details">
      <h2 className="city-details-name">{city.name}</h2>

      <div className="city-details-current">
        <div className="city-details-temp">
          {currentTemperature !== null ? (
            <>
              {currentTemperature}¬∞{unit}
            </>
          ) : (
            'brak danych'
          )}
        </div>
        <div className="city-details-icon">
          {currentWeather.iconCode && (
            <img
              src={`https://openweathermap.org/img/wn/${currentWeather.iconCode}@2x.png`}
              alt={`Pogoda: ${currentConditionLabel}`}
              style={{ width: 60, height: 60 }}
            />
          )}
          <span>{currentConditionLabel}</span>
        </div>
      </div>

      <div className="city-details-grid">
        <section className="city-details-section">
          <h3>Wiatr</h3>
          <p>
            {currentWeather.windSpeedKilometersPerHour !== null
              ? `${Math.round(currentWeather.windSpeedKilometersPerHour * 10) / 10} km/h`
              : 'brak danych'}
          </p>
          <p>{windDirection ? `Kierunek: ${windDirection}` : 'kierunek: brak danych'}</p>
        </section>

        <section className="city-details-section">
          <h3>Zachmurzenie</h3>
          <p>
            {currentWeather.cloudinessPercent !== null
              ? `${currentWeather.cloudinessPercent}%`
              : 'brak danych'}
          </p>
        </section>

        <section className="city-details-section">
          <h3>Wilgotno≈õƒá</h3>
          <p>
            {currentWeather.humidityPercent !== null
              ? `${currentWeather.humidityPercent}%`
              : 'brak danych'}
          </p>
        </section>

        <section className="city-details-section">
          <h3>Ci≈õnienie</h3>
          <p>
            {currentWeather.pressureHpa !== null
              ? `${currentWeather.pressureHpa} hPa`
              : 'brak danych'}
          </p>
        </section>

        <section className="city-details-section">
          <h3>Opady (dzi≈õ)</h3>
          {todayPrecipitation ? (
            <>
              <p>
                Prawdopodobie≈Ñstwo:{' '}
                {todayPrecipitation.precipitationProbabilityPercent === 0
                  ? '0% (brak opad√≥w)'
                  : `${todayPrecipitation.precipitationProbabilityPercent}%`}
              </p>
              <p>
                Rodzaj:{' '}
                {todayPrecipitation.precipitationProbabilityPercent === 0
                  ? 'brak opad√≥w'
                  : todayPrecipitation.precipitationTypeLabel}
              </p>
              <p>
                Ilo≈õƒá:{' '}
                {todayPrecipitation.precipitationAmountMillimeters === 0
                  ? '0 mm (brak opad√≥w)'
                  : `${todayPrecipitation.precipitationAmountMillimeters} mm`}
              </p>
            </>
          ) : (
            <p>Brak danych o opadach.</p>
          )}
        </section>
      </div>

      <section className="city-details-forecast">
        <h3>Prognoza na 5 dni</h3>
        {forecastDays.length === 0 ? (
          <p>Brak danych prognozy.</p>
        ) : (
          <ul className="forecast-list">
            {forecastDays.map((forecastDay) => {
              const minTemperature =
                forecastDay.minTemperatureCelsius !== null
                  ? convertTemperature(forecastDay.minTemperatureCelsius, unit)
                  : null;
              const maxTemperature =
                forecastDay.maxTemperatureCelsius !== null
                  ? convertTemperature(forecastDay.maxTemperatureCelsius, unit)
                  : null;

              return (
                <li key={forecastDay.dateKey} className="forecast-item">
                  <div className="forecast-day">{forecastDay.dayLabel}</div>

                  <div className="forecast-icon">
                    {forecastDay.iconCode && (
                      <img
                        src={`https://openweathermap.org/img/wn/${forecastDay.iconCode}.png`}
                        alt={forecastDay.mainConditionLabel}
                        className="forecast-icon-image"
                      />
                    )}
                    <span className="forecast-icon-text">
                      {forecastDay.mainConditionLabel}
                    </span>
                  </div>

                  <div className="forecast-temps">
                    {minTemperature !== null && maxTemperature !== null
                      ? `${minTemperature}¬∞${unit} ‚Äì ${maxTemperature}¬∞${unit}`
                      : 'brak danych'}
                  </div>

                  <div className="forecast-precip">
                    {forecastDay.precipitationProbabilityPercent === 0
                      ? 'brak opad√≥w'
                      : `${forecastDay.precipitationProbabilityPercent}% opad√≥w, ${forecastDay.precipitationAmountMillimeters} mm`}
                  </div>
                </li>
              );
            })}
          </ul>
        )}
      </section>
    </div>
  );
}

export default CityDetails;

```

SRC/COMPONENTS/CITYLIST.JSX:

```
import CityCard from './CityCard';

function CityList({
  cities,
  onSelectCity,
  selectedCityId,
  favoriteIds = [],
  onToggleFavorite,
}) {
  return (
    <ul className="city-list">
      {cities.map((city) => (
        <CityCard
          key={city.id}
          city={city}
          onSelect={onSelectCity}
          isSelected={city.id === selectedCityId}
          isFavorite={favoriteIds.includes(city.id)}
          onToggleFavorite={
            onToggleFavorite ? () => onToggleFavorite(city.id) : undefined
          }
        />
      ))}
    </ul>
  );
}

export default CityList;

```

SRC/COMPONENTS/FAVORITECITIESSLIDER.JSX:

```
import { useRef, useEffect } from 'react';
import FavoriteCityCard from './FavoriteCityCard';

function FavoriteCitiesSlider({ favoriteCities, selectedCityId, onSelectCity }) {
  const listWrapperRef = useRef(null);

  if (!favoriteCities || favoriteCities.length === 0) {
    return null;
  }

  const handleScroll = (direction) => {
    const wrapperElement = listWrapperRef.current;
    if (!wrapperElement) {
      return;
    }

    const scrollAmount = 260;
    if (direction === 'left') {
      wrapperElement.scrollLeft -= scrollAmount;
      if (wrapperElement.scrollLeft < 0) {
        wrapperElement.scrollLeft = 0;
      }
    } else {
      wrapperElement.scrollLeft += scrollAmount;
      const maxScrollLeft = wrapperElement.scrollWidth - wrapperElement.clientWidth;
      if (wrapperElement.scrollLeft > maxScrollLeft) {
        wrapperElement.scrollLeft = maxScrollLeft;
      }
    }
  };

  useEffect(() => {
    const wrapperElement = listWrapperRef.current;
    if (!wrapperElement) {
      return;
    }

    const interval = setInterval(() => {
      if (!wrapperElement) {
        return;
      }

      if (wrapperElement.scrollWidth <= wrapperElement.clientWidth) {
        return;
      }

      wrapperElement.scrollLeft += 1;

      const maxScrollLeft = wrapperElement.scrollWidth - wrapperElement.clientWidth;
      if (wrapperElement.scrollLeft >= maxScrollLeft - 1) {
        wrapperElement.scrollLeft = 0;
      }
    }, 40);

    return () => clearInterval(interval);
  }, [favoriteCities.length]);

  return (
    <section className="favorites-slider favorites-slider--lower">
      <div className="favorites-slider-header">
        <h3 className="favorites-slider-title">Ulubione miasta</h3>
        <div className="favorites-slider-arrows">
          <button
            type="button"
            className="favorites-slider-arrow"
            onClick={() => handleScroll('left')}
          >
            ‚Äπ
          </button>
          <button
            type="button"
            className="favorites-slider-arrow"
            onClick={() => handleScroll('right')}
          >
            ‚Ä∫
          </button>
        </div>
      </div>

      <div className="favorites-slider-list-wrapper" ref={listWrapperRef}>
        <div className="favorites-slider-list">
          {favoriteCities.map((city) => (
            <div key={city.id} className="favorites-slider-item">
              <FavoriteCityCard
                city={city}
                isActive={city.id === selectedCityId}
                onSelectCity={onSelectCity}
              />
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}

export default FavoriteCitiesSlider;

```

SRC/COMPONENTS/FAVORITECITYCARD.JSX:

```
import { useEffect, useState } from 'react';
import { useSelector } from 'react-redux';
import axios from 'axios';
import { convertTemperature } from '../utils/temperature';

function getWeatherDescription(mainCondition) {
  if (!mainCondition) {
    return 'Brak danych';
  }

  switch (mainCondition) {
    case 'Clear':
      return 'S≈Çonecznie';
    case 'Clouds':
      return 'Pochmurno';
    case 'Rain':
      return 'Deszcz';
    case 'Snow':
      return '≈önieg';
    case 'Thunderstorm':
      return 'Burza';
    case 'Drizzle':
      return 'M≈ºawka';
    case 'Mist':
    case 'Fog':
    case 'Haze':
    case 'Smoke':
    case 'Dust':
    case 'Sand':
    case 'Ash':
    case 'Squall':
    case 'Tornado':
      return 'Mglisto';
    default:
      return mainCondition;
  }
}

function FavoriteCityCard({ city, isActive, onSelectCity }) {
  const unit = useSelector((state) => state.temperature.unit);
  const [currentWeather, setCurrentWeather] = useState(null);

  useEffect(() => {
    const apiKey = import.meta.env.VITE_API_KEY;
    if (!apiKey) {
      setCurrentWeather(null);
      return;
    }

    let wasCancelled = false;

    const fetchWeather = async () => {
      try {
        const response = await axios.get('https://api.openweathermap.org/data/2.5/weather', {
          params: {
            lat: city.lat,
            lon: city.lon,
            units: 'metric',
            appid: apiKey,
          },
        });

        if (wasCancelled) return;

        const data = response.data;
        const temperatureCelsius = data.main?.temp ?? null;
        const mainCondition = data.weather?.[0]?.main ?? null;
        const iconCode = data.weather?.[0]?.icon ?? null;

        setCurrentWeather({
          temperatureCelsius,
          conditionLabel: getWeatherDescription(mainCondition),
          iconCode,
        });
      } catch (error) {
        if (!wasCancelled) {
          console.error('B≈ÇƒÖd pobierania danych ulubionego miasta:', error);
          setCurrentWeather(null);
        }
      }
    };

    fetchWeather();

    return () => {
      wasCancelled = true;
    };
  }, [city]);

  const temperature =
    currentWeather && currentWeather.temperatureCelsius !== null
      ? `${convertTemperature(currentWeather.temperatureCelsius, unit)}¬∞${unit}`
      : '‚Äî';

  const conditionLabel = currentWeather ? currentWeather.conditionLabel : '≈Åadowanie...';

  return (
    <li className="favorites-slider-item">
      <button
        type="button"
        className={`favorites-slider-card ${
          isActive ? 'favorites-slider-card--active' : ''
        }`}
        onClick={() => onSelectCity(city.id)}
      >
        <div className="favorites-slider-card-header">
          <span className="favorites-slider-city-name">{city.name}</span>
          <span className="favorites-slider-temp">{temperature}</span>
        </div>
        <div className="favorites-slider-card-footer">
          {currentWeather && currentWeather.iconCode && (
            <img
              src={`https://openweathermap.org/img/wn/${currentWeather.iconCode}.png`}
              alt={conditionLabel}
              className="favorites-slider-icon-image"
            />
          )}
          <span className="favorites-slider-condition-text">{conditionLabel}</span>
        </div>
      </button>
    </li>
  );
}

export default FavoriteCityCard;

```

SRC/DATA/CITIES.JS:

```
const cities = [
  {
    id: "warsaw",
    name: "Warszawa",
    lat: 52.2297,
    lon: 21.0122,
    isPolishCity: true,
  },
  {
    id: "krakow",
    name: "Krak√≥w",
    lat: 50.0647,
    lon: 19.945,
    isPolishCity: true,
  },
  {
    id: "gdansk",
    name: "Gda≈Ñsk",
    lat: 54.352,
    lon: 18.6466,
    isPolishCity: true,
  },
  {
    id: "wroclaw",
    name: "Wroc≈Çaw",
    lat: 51.1079,
    lon: 17.0385,
    isPolishCity: true,
  },
  {
    id: "poznan",
    name: "Pozna≈Ñ",
    lat: 52.4064,
    lon: 16.9252,
    isPolishCity: true,
  },

  { id: "london", name: "Londyn", lat: 51.5074, lon: -0.1278, isPolishCity: false },
  { id: "paris", name: "Pary≈º", lat: 48.8566, lon: 2.3522, isPolishCity: false },
  { id: "berlin", name: "Berlin", lat: 52.52, lon: 13.405, isPolishCity: false },
  { id: "rome", name: "Rzym", lat: 41.9028, lon: 12.4964, isPolishCity: false },
  { id: "madrid", name: "Madryt", lat: 40.4168, lon: -3.7038, isPolishCity: false },
  { id: "lisbon", name: "Lizbona", lat: 38.7223, lon: -9.1393, isPolishCity: false },
  { id: "vienna", name: "Wiede≈Ñ", lat: 48.2082, lon: 16.3738, isPolishCity: false },
  { id: "prague", name: "Praga", lat: 50.0755, lon: 14.4378, isPolishCity: false },
  { id: "budapest", name: "Budapeszt", lat: 47.4979, lon: 19.0402, isPolishCity: false },
  { id: "copenhagen", name: "Kopenhaga", lat: 55.6761, lon: 12.5683, isPolishCity: false },
  { id: "oslo", name: "Oslo", lat: 59.9139, lon: 10.7522, isPolishCity: false },
  { id: "stockholm", name: "Sztokholm", lat: 59.3293, lon: 18.0686, isPolishCity: false },
  { id: "helsinki", name: "Helsinki", lat: 60.1699, lon: 24.9384, isPolishCity: false },
  { id: "dublin", name: "Dublin", lat: 53.3498, lon: -6.2603, isPolishCity: false },
  { id: "athens", name: "Ateny", lat: 37.9838, lon: 23.7275, isPolishCity: false },
  { id: "amsterdam", name: "Amsterdam", lat: 52.3676, lon: 4.9041, isPolishCity: false },
  { id: "brussels", name: "Bruksela", lat: 50.8503, lon: 4.3517, isPolishCity: false },
  { id: "bern", name: "Berno", lat: 46.948, lon: 7.4474, isPolishCity: false },
  { id: "zagreb", name: "Zagrzeb", lat: 45.815, lon: 15.9819, isPolishCity: false },
  { id: "vilnius", name: "Wilno", lat: 54.6872, lon: 25.2797, isPolishCity: false },
  { id: "riga", name: "Ryga", lat: 56.9496, lon: 24.1052, isPolishCity: false },
  { id: "tallinn", name: "Tallinn", lat: 59.437, lon: 24.7536, isPolishCity: false },

  { id: "washington", name: "Waszyngton", lat: 38.9072, lon: -77.0369, isPolishCity: false },
  { id: "ottawa", name: "Ottawa", lat: 45.4215, lon: -75.6972, isPolishCity: false },
  { id: "mexico", name: "Meksyk", lat: 19.4326, lon: -99.1332, isPolishCity: false },
  { id: "buenosaires", name: "Buenos Aires", lat: -34.6037, lon: -58.3816, isPolishCity: false },
  { id: "brasilia", name: "Brasilia", lat: -15.8267, lon: -47.9218, isPolishCity: false },
  { id: "lima", name: "Lima", lat: -12.0464, lon: -77.0428, isPolishCity: false },
  { id: "santiago", name: "Santiago", lat: -33.4489, lon: -70.6693, isPolishCity: false },
  { id: "bogota", name: "Bogota", lat: 4.711, lon: -74.0721, isPolishCity: false },

  { id: "tokyo", name: "Tokio", lat: 35.6762, lon: 139.6503, isPolishCity: false },
  { id: "seoul", name: "Seul", lat: 37.5665, lon: 126.978, isPolishCity: false },
  { id: "beijing", name: "Pekin", lat: 39.9042, lon: 116.4074, isPolishCity: false },
  { id: "delhi", name: "Delhi", lat: 28.6139, lon: 77.209, isPolishCity: false },
  { id: "bangkok", name: "Bangkok", lat: 13.7563, lon: 100.5018, isPolishCity: false },
  { id: "singapore", name: "Singapur", lat: 1.3521, lon: 103.8198, isPolishCity: false },
  { id: "kualalumpur", name: "Kuala Lumpur", lat: 3.139, lon: 101.6869, isPolishCity: false },
  { id: "jakarta", name: "D≈ºakarta", lat: -6.2088, lon: 106.8456, isPolishCity: false },
  { id: "riyadh", name: "Rijad", lat: 24.7136, lon: 46.6753, isPolishCity: false },
  { id: "telaviv", name: "Tel Awiw", lat: 32.0853, lon: 34.7818, isPolishCity: false },
  { id: "istanbul", name: "Stambu≈Ç", lat: 41.0082, lon: 28.9784, isPolishCity: false },

  { id: "cairo", name: "Kair", lat: 30.0444, lon: 31.2357, isPolishCity: false },
  { id: "nairobi", name: "Nairobi", lat: -1.2864, lon: 36.8172, isPolishCity: false },
  { id: "johannesburg", name: "Johannesburg", lat: -26.2041, lon: 28.0473, isPolishCity: false },
  { id: "lagos", name: "Lagos", lat: 6.5244, lon: 3.3792, isPolishCity: false },

  { id: "canberra", name: "Canberra", lat: -35.2809, lon: 149.13, isPolishCity: false },
  { id: "sydney", name: "Sydney", lat: -33.8688, lon: 151.2093, isPolishCity: false },
  { id: "wellington", name: "Wellington", lat: -41.2865, lon: 174.7762, isPolishCity: false },
];

export default cities;

```

SRC/UTILS/TEMPERATURE.JS:

```
export function convertTemperature(valueC, unit) {
  if (unit === 'F') {
    return Math.round((valueC * 9) / 5 + 32);
  }
  if (unit === 'K') {
    return Math.round(valueC + 273.15);
  }
  return Math.round(valueC);
}

```

SRC/APP.CSS:

```
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #020617 100%);
  color: #e5e7eb;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* HEADER */

.app-header {
  padding: 1rem 1.75rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.4);
  background: rgba(15, 23, 42, 0.96);
  backdrop-filter: blur(14px);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.75rem;
  position: sticky;
  top: 0;
  z-index: 10;
}

.app-header-left {
  display: flex;
  align-items: center;
  gap: 1.25rem;
}

.app-title {
  margin: 0;
  font-size: 1.7rem;
  letter-spacing: 0.06em;
  font-weight: 700;
  text-transform: uppercase;
  background: linear-gradient(120deg, #bfdbfe, #60a5fa, #a5b4fc);
  -webkit-background-clip: text;
  color: transparent;
}

.app-nav {
  display: flex;
  gap: 0.7rem;
}

.app-nav-link {
  text-decoration: none;
  color: #e5e7eb;
  font-size: 0.9rem;
  opacity: 0.85;
  padding: 0.3rem 0.65rem;
  border-radius: 999px;
  transition: background 0.15s ease, opacity 0.15s ease, transform 0.1s ease;
}

.app-nav-link:hover {
  opacity: 1;
  background: rgba(37, 99, 235, 0.35);
  transform: translateY(-1px);
}

/* UNIT SWITCHER */

.unit-switcher {
  display: flex;
  gap: 0.25rem;
  padding: 0.2rem;
  border-radius: 999px;
  background: rgba(15, 23, 42, 0.9);
  border: 1px solid rgba(148, 163, 184, 0.6);
}

.unit-button {
  border: none;
  background: transparent;
  color: #e5e7eb;
  border-radius: 999px;
  padding: 0.15rem 0.6rem;
  font-size: 0.78rem;
  cursor: pointer;
  transition: background 0.15s ease, transform 0.1s ease, color 0.15s ease;
}

.unit-button--active {
  background: rgba(59, 130, 246, 0.9);
  color: #0b1120;
  font-weight: 600;
  box-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
}

.unit-button:hover {
  background: rgba(30, 64, 175, 0.7);
}

/* MAIN LAYOUT */

.app-main {
  flex: 1;
  display: grid;
  grid-template-columns: 320px minmax(0, 1fr);
  gap: 1.25rem;
  padding: 1.25rem 1.75rem 1.5rem;
  box-sizing: border-box;
}

/* SIDEBAR */

.app-sidebar {
  background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.25), rgba(15, 23, 42, 0.98));
  border-radius: 0.9rem;
  padding: 0.9rem;
  border: 1px solid rgba(148, 163, 184, 0.5);
  box-shadow: 0 16px 34px rgba(15, 23, 42, 0.9);
  display: flex;
  flex-direction: column;
  min-height: 0;
}

/* CONTENT WRAPPER */

.app-details {
  background: transparent;
  border: none;
  box-shadow: none;
  padding: 0.4rem 0;
  min-height: 0;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
}

/* TITLES */

.section-title {
  margin: 0 0 0.6rem;
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #cbd5f5;
}

.city-group-title {
  margin: 0.4rem 0 0.3rem;
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #9ca3af;
}

/* SEARCH */

.search-input {
  width: 100%;
  margin-bottom: 0.45rem;
  padding: 0.45rem 0.7rem;
  border-radius: 0.5rem;
  border: 1px solid rgba(148, 163, 184, 0.9);
  background: rgba(15, 23, 42, 0.97);
  color: #e5e7eb;
  font-size: 0.86rem;
  outline: none;
  transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
}

.search-input::placeholder {
  color: rgba(148, 163, 184, 0.9);
}

.search-input:focus {
  border-color: rgba(191, 219, 254, 0.95);
  box-shadow: 0 0 0 1px rgba(191, 219, 254, 0.8);
  background: rgba(15, 23, 42, 1);
}

/* CITY LIST */

.city-list {
  list-style: none;
  margin: 0 0 0.4rem;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 0.45rem;
  max-height: 60vh;
  overflow-y: auto;
  padding-right: 0.15rem;
}

.city-list::-webkit-scrollbar {
  width: 6px;
}

.city-list::-webkit-scrollbar-track {
  background: transparent;
}

.city-list::-webkit-scrollbar-thumb {
  background: rgba(148, 163, 184, 0.9);
  border-radius: 999px;
}

/* CITY CARD */

.city-card {
  margin: 0;
}

.city-card-button {
  width: 100%;
  text-align: left;
  border: 1px solid rgba(15, 23, 42, 0.9);
  border-radius: 0.6rem;
  padding: 0.55rem 0.75rem;
  background: rgba(15, 23, 42, 0.97);
  color: inherit;
  cursor: pointer;
  display: block;
  font-size: 0.86rem;
  transition:
    background 0.15s ease,
    transform 0.12s ease,
    border-color 0.15s ease,
    box-shadow 0.15s ease;
}

.city-card-button:hover {
  background: rgba(30, 64, 175, 0.55);
  transform: translateY(-1px);
  border-color: rgba(129, 140, 248, 0.9);
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.95);
}

.city-card--selected .city-card-button {
  background: radial-gradient(circle at top left, rgba(59, 130, 246, 0.65), rgba(15, 23, 42, 0.98));
  border-color: rgba(191, 219, 254, 0.95);
  box-shadow: 0 14px 34px rgba(30, 64, 175, 0.95);
}

.city-card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.4rem;
}

.city-card-name {
  font-size: 0.9rem;
  margin: 0;
  font-weight: 500;
}

.city-card-temp {
  font-weight: 600;
}

.city-card-meta {
  margin-top: 0.25rem;
  font-size: 0.78rem;
  display: flex;
  align-items: center;
  gap: 0.45rem;
  opacity: 0.9;
}

/* FAVORITE STAR */

.fav-button {
  margin-left: auto;
  border: none;
  background: transparent;
  color: #e5e7eb;
  cursor: pointer;
  font-size: 1.1rem;
  line-height: 1;
  padding: 0.05rem 0.1rem;
  transition: transform 0.15s ease, color 0.15s ease, text-shadow 0.15s ease;
}

.fav-button:hover {
  transform: scale(1.08) translateY(-1px);
  color: #fde68a;
}

.fav-button--active {
  color: #facc15;
  text-shadow: 0 0 10px rgba(250, 204, 21, 0.9);
}

/* CITY DETAILS ‚Äì wiƒôksza karta na ≈õrodku */

.city-details {
  width: 100%;
  max-width: 1200px;
  background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.94));
  border-radius: 1rem;
  padding: 1.4rem 1.6rem 1.5rem;
  border: 1px solid rgba(148, 163, 184, 0.5);
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.95);
  display: flex;
  flex-direction: column;
  gap: 0.9rem;
}

/* nag≈Ç√≥wek */

.city-details-name {
  margin: 0;
  font-size: 1.6rem;
  font-weight: 600;
  letter-spacing: 0.03em;
}

.city-details-current {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.9rem;
  padding-bottom: 0.6rem;
  border-bottom: 1px solid rgba(55, 65, 81, 0.85);
}

.city-details-temp {
  font-size: 2.4rem;
  font-weight: 700;
}

.city-details-icon {
  font-size: 0.98rem;
  opacity: 0.9;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* GRID */

.city-details-grid {
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 0.8rem;
}

.city-details-section {
  background: rgba(15, 23, 42, 0.95);
  border-radius: 0.9rem;
  padding: 0.9rem 1rem;
  border: 1px solid rgba(148, 163, 184, 0.55);
  font-size: 0.9rem;
  min-height: 130px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
}

.city-details-section h3 {
  margin: 0 0 0.35rem;
  font-size: 1rem;
  font-weight: 600;
  color: #dbeafe;
}

.city-details-section p {
  margin: 0.15rem 0;
}

/* FORECAST */

.city-details-forecast {
  margin-top: 0.4rem;
}

.city-details-forecast h3 {
  margin: 0 0 0.4rem;
  font-size: 0.96rem;
  font-weight: 600;
  color: #dbeafe;
}

.forecast-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: grid;
  grid-template-columns: repeat(5, minmax(0, 1fr));
  gap: 0.8rem;
}

.forecast-item {
  background: rgba(15, 23, 42, 0.95);
  border-radius: 0.9rem;
  padding: 0.9rem 1rem;
  border: 1px solid rgba(148, 163, 184, 0.55);
  min-height: 130px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  font-size: 0.9rem;
  text-align: center;
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
}

.forecast-day {
  font-weight: 600;
  font-size: 0.95rem;
}

.forecast-temps {
  opacity: 0.95;
  font-size: 0.9rem;
}

.forecast-icon {
  font-size: 0.85rem;
  opacity: 0.9;
}

.forecast-precip {
  font-size: 0.8rem;
  color: #bfdbfe;
}

/* ABOUT TEXT */

.app-details p {
  margin: 0.25rem 0;
  line-height: 1.5;
  color: #e5e7eb;
  font-size: 0.9rem;
}

/* FAVORITES SLIDER */

.favorites-slider {
  width: 100%;
  max-width: 1200px;
  margin-top: 1.1rem;
  background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
  border-radius: 0.9rem;
  border: 1px solid rgba(148, 163, 184, 0.55);
  box-shadow: 0 16px 34px rgba(15, 23, 42, 0.95);
  padding: 1rem 1.1rem;
}

.favorites-slider--lower {
  margin-top: 1.8rem;
}

.favorites-slider-header {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 0.6rem;
}

.favorites-slider-title {
  margin: 0;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #cbd5f5;
  text-align: center;
}

.favorites-slider-arrows {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.favorites-slider-arrow {
  width: 24px;
  height: 24px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.8);
  background: rgba(15, 23, 42, 0.98);
  color: #e5e7eb;
  font-size: 0.85rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition:
    background 0.15s ease,
    transform 0.12s ease,
    border-color 0.15s ease,
    box-shadow 0.15s ease;
}

.favorites-slider-arrow:hover {
  background: rgba(37, 99, 235, 0.85);
  border-color: rgba(191, 219, 254, 0.95);
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.95);
  transform: translateY(-1px);
}

.favorites-slider-list-wrapper {
  width: 100%;
  overflow-x: auto;
  padding-bottom: 0.3rem;
}

.favorites-slider-list-wrapper::-webkit-scrollbar {
  height: 6px;
}

.favorites-slider-list-wrapper::-webkit-scrollbar-track {
  background: transparent;
}

.favorites-slider-list-wrapper::-webkit-scrollbar-thumb {
  background: rgba(148, 163, 184, 0.9);
  border-radius: 999px;
}

.favorites-slider-list {
  display: flex;
  flex-direction: row;
  gap: 0.8rem;
  justify-content: flex-start;
  align-items: stretch;
  margin: 0;
  padding: 0;
}

.favorites-slider-item {
  flex: 0 0 auto;
}

.favorites-slider-card {
  width: 230px;
  min-height: 130px;
  border-radius: 0.9rem;
  border: 1px solid rgba(55, 65, 81, 0.9);
  background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
  color: #e5e7eb;
  cursor: pointer;
  padding: 0.9rem 1rem;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  gap: 0.5rem;
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.9);
  transition:
    background 0.15s ease,
    transform 0.12s ease,
    border-color 0.15s ease,
    box-shadow 0.15s ease;
}

.favorites-slider-card:hover {
  background: rgba(30, 64, 175, 0.75);
  border-color: rgba(191, 219, 254, 0.95);
  box-shadow: 0 14px 34px rgba(15, 23, 42, 0.95);
  transform: translateY(-2px);
}

.favorites-slider-card--active {
  background: radial-gradient(circle at top left, rgba(59, 130, 246, 0.85), rgba(15, 23, 42, 0.98));
  border-color: rgba(191, 219, 254, 0.98);
  box-shadow: 0 18px 40px rgba(30, 64, 175, 0.98);
}

.favorites-slider-card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.4rem;
  font-size: 0.9rem;
}

.favorites-slider-city-name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.favorites-slider-temp {
  font-weight: 600;
}

.favorites-slider-card-footer {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.82rem;
  opacity: 0.9;
}

.favorites-slider-condition-emoji {
  font-size: 1.1rem;
}

.favorites-slider-condition-text {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* RESPONSIVE */

@media (max-width: 1024px) {
  .app-main {
    grid-template-columns: 260px minmax(0, 1fr);
    padding: 1rem 1.25rem 1.25rem;
  }

  .city-details-grid {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .city-details {
    max-width: 960px;
  }

  .favorites-slider {
    max-width: 960px;
  }

  .forecast-list {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}

@media (max-width: 768px) {
  .app-header {
    padding: 0.9rem 1.1rem;
    flex-direction: column;
    align-items: flex-start;
  }

  .app-header-left {
    width: 100%;
    justify-content: space-between;
  }

  .app-main {
    grid-template-columns: 1fr;
    padding: 0.9rem 1rem 1.1rem;
    gap: 0.9rem;
  }

  .app-sidebar {
    order: 2;
  }

  .app-details {
    order: 1;
    align-items: stretch;
  }

  .city-details {
    max-width: 100%;
  }

  .favorites-slider {
    max-width: 100%;
  }

  .city-details-current {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.4rem;
  }

  .city-details-grid {
    grid-template-columns: 1fr;
  }

  .city-list {
    max-height: 40vh;
  }

  .forecast-list {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

@media (max-width: 480px) {
  .app-main {
    padding: 0.8rem;
  }

  .app-sidebar {
    padding: 0.8rem 0.85rem;
  }

  .city-details {
    padding: 0.9rem;
    border-radius: 0.8rem;
  }

  .city-details-temp {
    font-size: 2.1rem;
  }

  .forecast-list {
    grid-template-columns: 1fr;
  }

  .forecast-item {
    min-height: 115px;
    padding: 0.8rem 0.9rem;
  }
}

/* FOCUS */

button:focus-visible,
a:focus-visible,
input:focus-visible {
  outline: 2px solid rgba(191, 219, 254, 0.9);
  outline-offset: 2px;
}


.forecast-icon {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.forecast-icon-image {
  width: 34px;
  height: 34px;
  object-fit: contain;
}

.forecast-icon-text {
  font-size: 0.85rem;
}

.favorites-slider-icon-image {
  width: 28px;
  height: 28px;
  object-fit: contain;
}

```

SRC/APP.JSX:

```
import { useState, useMemo, useCallback, useEffect } from 'react';
import { Routes, Route, Link } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import cities from './data/cities';
import CityList from './components/CityList';
import CityDetails from './components/CityDetails';
import FavoriteCitiesSlider from './components/FavoriteCitiesSlider';
import { setUnit, toggleFavorite } from './store';
import './App.css';

function HomePage() {
  const [selectedCityId, setSelectedCityId] = useState(cities[0].id);
  const [search, setSearch] = useState('');
  const favoriteIds = useSelector((state) => state.favorites.ids);
  const dispatch = useDispatch();

  const handleSelectCity = useCallback((cityId) => {
    setSelectedCityId(cityId);
  }, []);

  const handleToggleFavorite = useCallback(
    (cityId) => {
      dispatch(toggleFavorite(cityId));
    },
    [dispatch],
  );

  const filteredCities = useMemo(() => {
    const searchTerm = search.trim().toLowerCase();
    if (!searchTerm) {
      return cities;
    }
    return cities.filter((city) => city.name.toLowerCase().includes(searchTerm));
  }, [search]);

  const filteredPolishCities = useMemo(
    () => filteredCities.filter((city) => city.isPolishCity),
    [filteredCities],
  );

  const filteredForeignCities = useMemo(
    () => filteredCities.filter((city) => !city.isPolishCity),
    [filteredCities],
  );

  const selectedCity = useMemo(() => {
    return (
      filteredCities.find((city) => city.id === selectedCityId) ||
      filteredCities[0] ||
      null
    );
  }, [filteredCities, selectedCityId]);

  const favoriteCities = useMemo(
    () => cities.filter((city) => favoriteIds.includes(city.id)),
    [favoriteIds],
  );

  useEffect(() => {
    if (!selectedCity && filteredCities.length > 0) {
      setSelectedCityId(filteredCities[0].id);
    }
  }, [filteredCities, selectedCity]);

  return (
    <main className="app-main">
      <section className="app-sidebar">
        <h2 className="section-title">Miasta</h2>
        <input
          className="search-input"
          type="text"
          placeholder="Szukaj miasta..."
          value={search}
          onChange={(event) => setSearch(event.target.value)}
        />

        {filteredPolishCities.length > 0 && (
          <>
            <h3 className="city-group-title">Miasta w Polsce</h3>
            <CityList
              cities={filteredPolishCities}
              onSelectCity={handleSelectCity}
              selectedCityId={selectedCityId}
              favoriteIds={favoriteIds}
              onToggleFavorite={handleToggleFavorite}
            />
          </>
        )}

        {filteredForeignCities.length > 0 && (
          <>
            <h3 className="city-group-title">Miasta na ≈õwiecie</h3>
            <CityList
              cities={filteredForeignCities}
              onSelectCity={handleSelectCity}
              selectedCityId={selectedCityId}
              favoriteIds={favoriteIds}
              onToggleFavorite={handleToggleFavorite}
            />
          </>
        )}
      </section>

      <section className="app-details">
        {selectedCity ? (
          <>
            <CityDetails city={selectedCity} />
            {favoriteCities.length > 0 && (
              <FavoriteCitiesSlider
                favoriteCities={favoriteCities}
                selectedCityId={selectedCityId}
                onSelectCity={handleSelectCity}
              />
            )}
          </>
        ) : (
          <p>Brak miast do wy≈õwietlenia.</p>
        )}
      </section>
    </main>
  );
}

function FavoritesPage() {
  const favoriteIds = useSelector((state) => state.favorites.ids);
  const [selectedCityId, setSelectedCityId] = useState(null);
  const dispatch = useDispatch();

  const favoriteCities = useMemo(
    () => cities.filter((city) => favoriteIds.includes(city.id)),
    [favoriteIds],
  );

  const favoritePolishCities = useMemo(
    () => favoriteCities.filter((city) => city.isPolishCity),
    [favoriteCities],
  );

  const favoriteForeignCities = useMemo(
    () => favoriteCities.filter((city) => !city.isPolishCity),
    [favoriteCities],
  );

  useEffect(() => {
    if (favoriteCities.length > 0 && !selectedCityId) {
      setSelectedCityId(favoriteCities[0].id);
    }
  }, [favoriteCities, selectedCityId]);

  const selectedCity = useMemo(() => {
    return favoriteCities.find((city) => city.id === selectedCityId) || null;
  }, [favoriteCities, selectedCityId]);

  const handleSelectCity = useCallback((cityId) => {
    setSelectedCityId(cityId);
  }, []);

  const handleToggleFavorite = useCallback(
    (cityId) => {
      dispatch(toggleFavorite(cityId));
    },
    [dispatch],
  );

  return (
    <main className="app-main">
      <section className="app-sidebar">
        <h2 className="section-title">Ulubione miasta</h2>

        {favoriteCities.length === 0 && (
          <p>Brak ulubionych miast. Dodaj je na stronie g≈Ç√≥wnej.</p>
        )}

        {favoritePolishCities.length > 0 && (
          <>
            <h3 className="city-group-title">Miasta w Polsce</h3>
            <CityList
              cities={favoritePolishCities}
              onSelectCity={handleSelectCity}
              selectedCityId={selectedCityId}
              favoriteIds={favoriteIds}
              onToggleFavorite={handleToggleFavorite}
            />
          </>
        )}

        {favoriteForeignCities.length > 0 && (
          <>
            <h3 className="city-group-title">Miasta na ≈õwiecie</h3>
            <CityList
              cities={favoriteForeignCities}
              onSelectCity={handleSelectCity}
              selectedCityId={selectedCityId}
              favoriteIds={favoriteIds}
              onToggleFavorite={handleToggleFavorite}
            />
          </>
        )}
      </section>

      <section className="app-details">
        {selectedCity ? (
          <CityDetails city={selectedCity} />
        ) : favoriteCities.length > 0 ? (
          <p>Wybierz miasto z listy ulubionych.</p>
        ) : (
          <p>Brak ulubionych miast.</p>
        )}
      </section>
    </main>
  );
}

function AboutPage() {
  return (
    <main className="app-main">
      <section className="app-details">
        <h2>O aplikacji</h2>
        <p>Prosta aplikacja pogodowa stworzona na projekt zaliczeniowy.</p>
      </section>
    </main>
  );
}

function App() {
  const unit = useSelector((state) => state.temperature.unit);
  const dispatch = useDispatch();

  const handleChangeUnit = (newUnit) => {
    dispatch(setUnit(newUnit));
  };

  return (
    <div className="app">
      <header className="app-header">
        <div className="app-header-left">
          <h1 className="app-title">POGODA</h1>
          <nav className="app-nav">
            <Link className="app-nav-link" to="/">
              Strona g≈Ç√≥wna
            </Link>
            <Link className="app-nav-link" to="/favorites">
              Ulubione
            </Link>
            <Link className="app-nav-link" to="/about">
              O aplikacji
            </Link>
          </nav>
        </div>
        <div className="unit-switcher">
          <button
            className={`unit-button ${unit === 'C' ? 'unit-button--active' : ''}`}
            onClick={() => handleChangeUnit('C')}
          >
            ¬∞C
          </button>
          <button
            className={`unit-button ${unit === 'F' ? 'unit-button--active' : ''}`}
            onClick={() => handleChangeUnit('F')}
          >
            ¬∞F
          </button>
          <button
            className={`unit-button ${unit === 'K' ? 'unit-button--active' : ''}`}
            onClick={() => handleChangeUnit('K')}
          >
            K
          </button>
        </div>
      </header>

      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/favorites" element={<FavoritesPage />} />
        <Route path="/about" element={<AboutPage />} />
      </Routes>
    </div>
  );
}

export default App;

```

SRC/INDEX.CSS:

```
:root {
  color-scheme: dark;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
}

#root {
  min-height: 100vh;
}

```

SRC/MAIN.JSX:

```
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { Provider } from 'react-redux';
import App from './App.jsx';
import store from './store';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <Provider store={store}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </Provider>
  </React.StrictMode>,
);

```

SRC/STORE.JS:

```
import { configureStore, createSlice } from '@reduxjs/toolkit';

const persisted = (() => {
  if (typeof localStorage === 'undefined') return null;
  try {
    const raw = localStorage.getItem('weather-settings');
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
})();

const temperatureSlice = createSlice({
  name: 'temperature',
  initialState: { unit: persisted?.unit || 'C' },
  reducers: {
    setUnit(state, action) {
      state.unit = action.payload;
    },
  },
});

const favoritesSlice = createSlice({
  name: 'favorites',
  initialState: { ids: persisted?.favorites || [] },
  reducers: {
    toggleFavorite(state, action) {
      const id = action.payload;
      if (state.ids.includes(id)) {
        state.ids = state.ids.filter((x) => x !== id);
      } else {
        state.ids.push(id);
      }
    },
  },
});

export const { setUnit } = temperatureSlice.actions;
export const { toggleFavorite } = favoritesSlice.actions;

const store = configureStore({
  reducer: {
    temperature: temperatureSlice.reducer,
    favorites: favoritesSlice.reducer,
  },
});

if (typeof localStorage !== 'undefined') {
  store.subscribe(() => {
    const state = store.getState();
    const data = {
      unit: state.temperature.unit,
      favorites: state.favorites.ids,
    };
    localStorage.setItem('weather-settings', JSON.stringify(data));
  });
}

export default store;

```

INDEX.HTML:

```
<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>POGODA</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

```

